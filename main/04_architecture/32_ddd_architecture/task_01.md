## Q1-1. 認可の知識をどのレイヤで表現すべきか

ドメイン or ユースケース

[参照](https://github.com/little-hands/ddd-q-and-a/issues/121)

## Q1-2. 認証結果を反映するロジックをどのレイヤに実装すべきか

実装をインフラに、呼び出しをユースケースに実装

[(参照) 松原さんの記事](https://zenn.dev/dowanna6/articles/5c05ab671fb7ab)

## Q1-3. User エンティティに認証にかかわるプロパティがいっぱい生えたときに起こる問題（キーワード：認証コンテキスト、アクセスコンテキストなど）

複数の概念を汎用的に含んだモデルになってしまう。
認証済みのユーザーは管理者として扱われたり、コンテキストに応じて変化していくべき。

## Q3. 複数集約の整合性を担保する方法

上から順に易～難（比例して整合性を担保しやすくなる）

- ユースケースで複数集約更新
- ドメインサービス
- ドメインイベント
- 今回のパターンであれば DB 側でトリガーを引くなどありか（仮）

## Q4.ブログサービスで、文字数上限の 1000 文字を超えたらエラーが生じるようにエンティティにバリデーションを実装したとする

### 起こりうる問題

- エラーが起こりうるものなのかどうか、呼び出し元で判断がつきにくくなる（呼び出し側がコードの使い方についてたくさん知らなければいけない＝例外が発生することを知らなければ適切に使えない）

[(参照)松原さんの記事](https://zenn.dev/dowanna6/articles/82ba2d5ee6ae76)

### 他に考えうる設計パターン

- 文字数制限は DB 容量上の制約でありドメイン知識ではなくシステム都合ともいえる。その意味ではアプリケーションレイヤ－以下で制約すればいいのではと思った。

[(参照)バリデーションには 3 種類ある](https://blog.ohgaki.net/there-are-3-types-of-validations)

### モナドを活用するには（キーワード：Result 型）

型をうまく使えばコンパイルエラーで事前にエラーハンドリングが必要なことを知らせてくれる

[(参照)TypeScript のエラーハンドリングを考える](https://qiita.com/frozenbonito/items/e708dfb3ab7c1fd3824d)
