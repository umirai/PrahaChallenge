# 質問回答

### デッドロックとは
複数クライアントからの同一レコードの更新要求に先立ち、DBでは競合を避けるためにまずはロックを取得する。ロックを取得したクライアントAは更新可能で、クライアントBはロック解除待ちとなる。Aが更新完了後、ロック解除されればクライアントBは更新可能になるが、トランザクション単位でレコードXとYを別クライアントから操作したい場合、お互いにロック解除を待機する状態＝デッドロックが発生する。デッドロック発生時は、１つのトランザクションを強制終了するしかない。デッドロックの発生確率を下げるには

- トランザクションを短時間で終わるように工夫する
- 更新順序を工夫する
- デッドロックを自動検出する設定をしておく（Postgresのdeadlock_timeout）
- etc...

### ISOLATION LEVELについて
1. read uncommitted
   - ダーティリード、ファジーリード、ファントムリードすべて起こる
   - その代わり早い
2. read committed
   - ファジーリード、ファントムリードが起こる
3. repeatable read
   - ファントムリードが起こる
4. serializable
   - 最も安全だが、最も性能が低い

### 行レベルのロックとテーブルレベルのロックの違い
- 対象レコードのみをロックするか、テーブル内全レコードをロックするかの違い

### 悲観ロックと楽観ロックの違い
ロックをかけるタイミングが違う。

1. データの確認(SELECT)
2. データの更新(UPDATE)

このフローで、①の時点でロックを掛ける場合を悲観的ロック、掛けない場合は楽観的ロック。使い分けはこの仕様をもとに考える。複数人同時編集の可能性があれば悲観ロックを使うべきだし、取得から更新までにユーザー操作が必要な時間が長ければ、楽観ロックでいい。楽観ロックの場合はレコード単位でバージョンカラムを持つ。

### 参照
- [第12回　デッドロックについて](https://oss-db.jp/dojo/dojo_12)
- [トランザクション分離レベル](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E5%88%86%E9%9B%A2%E3%83%AC%E3%83%99%E3%83%AB#:~:text=%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E5%88%86%E9%9B%A2%E3%83%AC%E3%83%99%E3%83%AB%20%EF%BC%88%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%B6%E3%82%93,%E7%8B%AC%E7%AB%8B%E6%80%A7%E3%83%AC%E3%83%99%E3%83%AB%E3%81%A8%E3%82%82%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%80%82)
- [トランザクション分離レベルについてのまとめ](https://qiita.com/song_ss/items/38e514b05e9dabae3bdb)
- [データを保護するロックの仕組み](https://www.teradata-jp.com/post/col05i)
- [排他制御（楽観ロック・悲観ロック）の基礎　](https://qiita.com/NagaokaKenichi/items/73040df85b7bd4e9ecfc)